    def isMatch(self, A, B):
        """ 
        A is source B is pattern 
        Implement regular expression matching with support for '.' and '*' 
            '.' Matches any single character.
            '*' Matches zero or more of the preceding element.
            The matching should cover the entire input string (not partial)
        Example:
            isMatch("aa","a") -> false
            isMatch("aa","aa") -> true
            isMatch("aaa","aa") -> false
            isMatch("aa", "a*") -> true
            isMatch("aa", ".*") -> true
            isMatch("ab", ".*") -> true
            isMatch("aab", "c*a*b") -> true
        """
        
        m = len(A)
        n = len(B)
        f = [[None for j in range(n+1)] for i in range(m+1)]
        f[0][0] = True
        for j in range(1, n+1):
            f[0][j] = False
            if B[j-1] == '*' and j >= 2:
                f[0][j] = f[0][j-2]
        
        for i in range(1, m+1):
            f[i][0] = False
            for j in range(1, n+1):
                f[i][j] = False
                if B[j-1] == '*' and j >= 2:
                    f[i][j] = f[i][j-2]
                    if B[j-2] in (A[i-1], '.'):
                        f[i][j] |= f[i-1][j]
                elif B[j-1] in (A[i-1], '.'):
                    f[i][j] = f[i-1][j-1]
                    
        return f[m][n]

    def __isMatch(self, s, p):
        import re
        return re.match(p + '$', s) != None


    def _bad_isMatch(self, s, p):
        """ http://articles.leetcode.com/regular-expression-matching """
        print "s, p = ", s, " | " , p 
        
        if len(p) == 0:
            return len(s) == 0
        
        if len(p) <= 1:
            return len(s) == len(p)
        
        # next char is not '*': must match current character
        if len(p)>=2 and p[1] != '*':
            #assert(p[0] != '*');
            return (len(s)>0 and (p[0] == s[0] or p[0] == '.')) and self.isMatch(s[1:], p[1:])

        # next char is '*'
        # while ((p[0] == s[0]) or (p[0] == '.' and len(s)>0)):
        while len(s)>0 and (p[0] == s[0] or p[0] == '.'):
            if self.isMatch(s, p[2:]):
                return True
            print "old s: ", s
            s = s[1:]
            print "new s: ", s
            #if len(s)==0 or len(p)==0:
            #    break

        return self.isMatch(s, p[2:])
